"""
1239. Maximum Length of a Concatenated String with Unique Characters_M

https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/

#################################
考点或思路:
[solution: backtracking]
Similar problems:
22. Generate Parentheses : https://leetcode.com/problems/generate-parentheses/

"""


from typing import List
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        """
        time:06/23/2022  10:40
        [Approach][recursion][backtracking]
        First, there are multiple valid solution for a N pair of parentheses.
        All the possible solutions can be a leaf of a tree.
        So they can be generated by backtracking.
                                  "("
                        /                   \
                    "(("                  "()"
                    /   \                /       \
                "((("   "(()"       "())"invalid      "()("  
                /        /  \                       /        \
            "((()"   "(()("  "(())"            "()()"        "()(("
        /            /     /   \               /  \           /     
    "((())"   "(()()" "(())("  "(()))"    "()()("  "()())"  "()(()" 
        /       \       \      invalid      /       invalid      /
       /         \       \                 /                    /
  "((()))"    "(()())" "(())()"         "()()()"             "()(())" 
        
        for a string of parentheses to be valid, during the process of generate, 
        the number of "(" should always bigger or equal to the number of ")".
        We can use it to "cut off" the invalid branches.
        time_O(2N * 2^2N) where N is the input, the number of the pairs of parentheses.
                        For each solution we 2N choices between "(" and ")". and for each solution we need 2N step to generate.
        Space_O(2N)
        
        res = []
        def backtracking(s, left, right):
            # here we have something else we can use to check if it comes to the end
            # len(s) needs time(N) ,meanwhile cnt == 0 ,needs time_O(1), 
            # so in this case we should start with n, and count down to zore.
            if len(s) == 2*n:
                res.append(s)
                return
            
            if left < n:
                backtracking(s+"(",left + 1, right)
            if right < left :
                backtracking(s+")",left, right + 1)
                
        backtracking("",0,0)
        return res
        """
        res = []
        def backtracking(s, left, right):
            # here we have something else we can use to check if it comes to the end
            # len(s) needs time(N) ,meanwhile cnt == 0 ,needs time_O(1), 
            # so in this case we should start with n, and count down to zore.
            if left == 0 and right == 0:
                res.append(s)
                return
            
            if left > 0:
                backtracking(s+"(",left - 1, right)
            if right > left :
                backtracking(s+")",left, right - 1)
                
        backtracking("",n,n)
        return res
        